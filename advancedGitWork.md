## Состояние **fast-forward**
Две ветки находятся в состоянии fast-forward, если одну из них можно «перемотать» вперёд и она будет содержать те же коммиты, что и другая. Это утверждение можно сформулировать иначе:
* при слиянии этих двух веток никак не возможен конфликт;
* истории этих двух веток не «разошлись»;
* одна ветка является продолжением другой.
  
Fast-forward слияние веток можно отключить флагом --no-ff. Например: git merge --no-ff add-docs.  
Также его можно отключить «навсегда» с помощью настройки merge.ff: git config [--global] merge.ff false.  
Если отключить слияние в режиме fast-forward, вместо «перемотки» ветки Git создаст в ней коммит слияния.  
  
*Многие проекты отключают fast-forward слияние веток, потому что при нём теряется часть информации. Результат выглядит так, как будто в main «просто появились» новые коммиты. Полноценный коммит слияния сохраняет всю информацию: в нём будет указано, какая именно ветка вливалась в main.*

## Состояние **non-fast-forward**
При слиянии не-fast-forward веток Git создаёт коммит слияния. Если конфликтов при слиянии нет, команда git merge отработает почти автоматически — только предложит вам ввести сообщение для нового коммита слияния.  
  
*Чаще всего сообщения к коммитам слияния не редактируют и оставляют «как предложил Git». Для таких случаев удобен флаг --no-edit: git merge --no-edit %another_branch%*


* Про связь **git push** и **fast-forward**  
Если main и main@origin находятся между собой в состоянии fast-forward, то git push «толкает» коммиты из локальной ветки в её удалённую копию. В итоге локальная и удалённая ветки будут содержать одинаковый набор коммитов. 

* Про связь **git push** и **non-fast-forward**  
Ветки main и main@origin «разошлись», то есть находятся в состоянии не-fast-forward. Если теперь попытаться выполнить команду git push, она выведет ошибку.

## Способы борьбы с **non-fast-forward** 
* **rebase**  
Эта операция позволяет изменить точку (коммит), от которой отделилась ветка. После такого перебазирования ветки будут в состоянии fast-forward, и git push сработает без ошибок. Однако у такого шага могут быть последствия. Например: могут возникать конфликты между изменениями, как при слиянии веток; если действовать неаккуратно, можно «сломать» репозиторий.
  
* **git push --force**
Это форсированный пуш. В этом случае команда git push --force просто «выкинет» (удалит) коммит, который есть в удалённой версии проекта, но нет в локальной.

# Модели веток. Простая feature branch модель
Подходы к работе с ветками — это правила, которые описывают, когда и для чего создаются ветки, какие в них коммиты и в какой момент происходит слияние веток. 
## Подходы:
* **Feature branch workflow** — для каждого нового изменения создаётся новая ветка, которая позже вливается в main с помощью git merge.
* **Git flow** — похож на feature branch workflow, но в нём создаётся больше веток, а изменения (коммиты) делят на разные типы: исправление, новая функциональность и так далее. Разные типы коммитов попадают в разные ветки.
* **Trunk-based** — похож на feature branch workflow, разве что участники проекта вливают (merge) свой код в основную ветку максимально часто. Например, каждый день.

## О feature branch workflow коротко
Основные правила:
* новая функциональность или исправление — новая ветка;
* когда код в feature-ветке готов, он вливается в main;
* в main всегда рабочая версия без «недоделок».  
  
Преимущества:
* простая модель;
* позволяет работать с Git в команде без лишних технических сложностей.